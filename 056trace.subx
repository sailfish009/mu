# primitives for emitting traces to a 'trace' stream, and for tests to make assertions on its contents
#
# A trace stream looks like a regular stream:
#   write : int  # index at which writes go
#   read : int  # index that we've read until
#   data : (array byte)  # prefixed by length as usual
# Usually the trace stream will be in a separate segment set aside for the purpose.
#
# primitives for operating on traces (arguments in quotes):
#   - initialize-trace-stream: populates Trace-stream with a new segment of the given 'size'
#   - trace: adds a 'line' to Trace-stream
#   - check-trace-contains: scans from Trace-stream's start for a matching 'line', prints a 'message' to stderr on failure
#   - check-trace-scans-to: scans from Trace-stream's read pointer for a matching 'line', prints a 'message' to stderr on failure

== data

# We'll save the address of the trace segment here.
Trace-stream:
    0/imm32

Trace-segment:
    0/imm32/curr
    0/imm32/limit

# Fake trace-stream for tests.
# Also illustrates the layout of the real trace-stream (segment).
_test-trace-stream:
    # current write index
    0/imm32
    # current read index
    0/imm32
    # length
    8/imm32
    # data
    00 00 00 00 00 00 00 00  # 8 bytes

== code
#   instruction                     effective address                                                   register    displacement    immediate
# . op          subop               mod             rm32          base        index         scale       r32
# . 1-3 bytes   3 bits              2 bits          3 bits        3 bits      3 bits        2 bits      2 bits      0/1/2/4 bytes   0/1/2/4 bytes

# Allocate a new segment for the trace stream, initialize its length, and save its address to Trace-stream.
# The Trace-stream segment will consist of variable-length lines separated by newlines (0x0a)
initialize-trace-stream:  # n : int
    # . prologue
    55/push-ebp
    89/copy                         3/mod/direct    5/rm32/ebp    .           .             .           4/r32/esp   .               .                 # copy esp to ebp
    # . save registers
    50/push-eax
    51/push-ecx
    # ecx = n
    8b/copy                         1/mod/*+disp8   5/rm32/ebp    .           .             .           1/r32/ecx   8/disp8         .                 # copy *(ebp+8) to ecx
    # Trace-segment = new-segment(n)
    # . . push args
    68/push  Trace-segment/imm32
    51/push-ecx
    # . . call
    e8/call  new-segment/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               8/imm32           # add to esp
    # copy Trace-segment->curr to *Trace-stream
    8b/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/eax   Trace-segment/disp32              # copy *Trace-segment to eax
    # watch point to catch Trace-stream leaks
#? $watch-1:
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/eax   Trace-stream/disp32               # copy eax to *Trace-stream
    # Trace-stream->length = n - 12
    # . ecx -= 12
    81          5/subop/subtract    3/mod/direct    1/rm32/ecx    .           .             .           .           .               0xc/imm32         # subtract from ecx
    # . Trace-stream->length = ecx
    89/copy                         1/mod/*+disp8   0/rm32/eax    .           .             .           1/r32/ecx   8/disp8         .                 # copy ecx to *(eax+8)
$initialize-trace-stream:end:
    # . restore registers
    59/pop-to-ecx
    58/pop-to-eax
    # . epilogue
    89/copy                         3/mod/direct    4/rm32/esp    .           .             .           5/r32/ebp   .               .                 # copy ebp to esp
    5d/pop-to-ebp
    c3/return

# Append a string to the given trace stream.
# Silently give up if it's already full. Or truncate the string if there isn't enough room.
trace:  # line : (address string)
    # . prologue
    55/push-ebp
    89/copy                         3/mod/direct    5/rm32/ebp    .           .             .           4/r32/esp   .               .                 # copy esp to ebp
    # . save registers
    50/push-eax
    51/push-ecx
    52/push-edx
    53/push-ebx
    56/push-esi
    57/push-edi
    # edi = *Trace-stream
    8b/copy                         0/mod/indirect  5/rm32/.disp32            .             .           7/r32/edi   Trace-stream/disp32               # copy *Trace-stream to edi
    # esi = line
    8b/copy                         1/mod/*+disp8   5/rm32/ebp    .           .                         6/r32/esi   8/disp8         .                 # copy *(ebp+8) to esi
    # ecx = t->write
    8b/copy                         0/mod/indirect  7/rm32/edi    .           .             .           1/r32/ecx   .               .                 # copy *edi to ecx
    # edx = t->length
    8b/copy                         1/mod/*+disp8   7/rm32/edi    .           .             .           2/r32/edx   8/disp8         .                 # copy *(edi+8) to edx
    # eax = _append-3(&t->data[t->write], &t->data[t->length], line)
    # . . push line
    56/push-esi
    # . . push &t->data[t->length]
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    7/base/edi  2/index/edx   .           3/r32/ebx   0xc/disp8       .                 # copy edi+edx+12 to ebx
    53/push-ebx
    # . . push &t->data[t->write]
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    7/base/edi  1/index/ecx   .           3/r32/ebx   0xc/disp8       .                 # copy edi+ecx+12 to ebx
    53/push-ebx
    # . . call
    e8/call  _append-3/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    # if (eax == 0) return
    3d/compare-eax-and  0/imm32
    74/jump-if-equal  $trace:end/disp8
    # t->write += eax
    01/add                          0/mod/indirect  7/rm32/edi    .           .             .           0/r32/eax   .               .                 # add eax to *edi
    # refresh ecx = t->write
    8b/copy                         0/mod/indirect  7/rm32/edi    .           .             .           1/r32/ecx   .               .                 # copy *edi to ecx
    # eax = _append-3(&t->data[t->write], &t->data[t->length], line)
    # . . push line
    68/push  Newline/imm32
    # . . push &t->data[t->length]
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    7/base/edi  2/index/edx   .           3/r32/ebx   0xc/disp8       .                 # copy edi+edx+12 to ebx
    53/push-ebx
    # . . push &t->data[t->write]
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    7/base/edi  1/index/ecx   .           3/r32/ebx   0xc/disp8       .                 # copy edi+ecx+12 to ebx
    53/push-ebx
    # . . call
    e8/call  _append-3/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    # t->write += eax
    01/add                          0/mod/indirect  7/rm32/edi    .           .             .           0/r32/eax   .               .                 # add eax to *edi
$trace:end:
    # . restore registers
    5f/pop-to-edi
    5e/pop-to-esi
    5b/pop-to-ebx
    5a/pop-to-edx
    59/pop-to-ecx
    58/pop-to-eax
    # . epilogue
    89/copy                         3/mod/direct    4/rm32/esp    .           .             .           5/r32/ebp   .               .                 # copy ebp to esp
    5d/pop-to-ebp
    c3/return

test-trace-single:
    # push *Trace-stream
    ff          6/subop/push        0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # push *Trace-stream
    # *Trace-stream = _test-trace-stream
    b8/copy-to-eax  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/eax   Trace-stream/disp32               # copy eax to *Trace-stream
    # clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # trace("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # check-ints-equal(*_test-trace-stream->data, 41/A 62/b 0a/newline 00, msg)
    # . . push args
    68/push  "F - test-trace-single"/imm32
    68/push  0x0a6241/imm32/Ab-newline
    # . . push *_test-trace-stream->data
    b8/copy-to-eax  _test-trace-stream/imm32
    ff          6/subop/push        1/mod/*+disp8   0/rm32/eax    .           .             .           .           0xc/disp8       .                 # push *(eax+12)
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    # pop into *Trace-stream
    8f          0/subop/pop         0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # pop into *Trace-stream
    # end
    c3/return

test-trace-appends:
    # push *Trace-stream
    ff          6/subop/push        0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # push *Trace-stream
    # *Trace-stream = _test-trace-stream
    b8/copy-to-eax  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/eax   Trace-stream/disp32               # copy eax to *Trace-stream
    # clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # trace("C")
    # . . push args
    68/push  "C"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # trace("D")
    # . . push args
    68/push  "D"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # check-ints-equal(*_test-trace-stream->data, 43/C 0a/newline 44/D 0a/newline, msg)
    # . . push args
    68/push  "F - test-trace-appends"/imm32
    68/push  0x0a440a43/imm32/C-newline-D-newline
    # . . push *_test-trace-stream->data
    b8/copy-to-eax  _test-trace-stream/imm32
    ff          6/subop/push        1/mod/*+disp8   0/rm32/eax    .           .             .           .           0xc/disp8       .                 # push *(eax+12)
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    # pop into *Trace-stream
    8f          0/subop/pop         0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # pop into *Trace-stream
    # end
    c3/return

test-trace-empty-line:
    # push *Trace-stream
    ff          6/subop/push        0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # push *Trace-stream
    # *Trace-stream = _test-trace-stream
    b8/copy-to-eax  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/eax   Trace-stream/disp32               # copy eax to *Trace-stream
    # clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # trace("")
    # . . push args
    68/push  ""/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # check-ints-equal(*_test-trace-stream->data, 0, msg)
    # . . push args
    68/push  "F - test-trace-empty-line"/imm32
    68/push  0/imm32
    # . . push *_test-trace-stream->data
    b8/copy-to-eax  _test-trace-stream/imm32
    ff          6/subop/push        1/mod/*+disp8   0/rm32/eax    .           .             .           .           0xc/disp8       .                 # push *(eax+12)
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    # pop into *Trace-stream
    8f          0/subop/pop         0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # pop into *Trace-stream
    # end
    c3/return

check-trace-contains:  # line : (address string), msg : (address string)
    # . prologue
    55/push-ebp
    89/copy                         3/mod/direct    5/rm32/ebp    .           .             .           4/r32/esp   .               .                 # copy esp to ebp
    # rewind-stream(*Trace-stream)
    # . . push args
    ff          6/subop/push        0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # push *Trace-stream
    # . . call
    e8/call  rewind-stream/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # check-trace-scans-to(line, msg)
    # . . push args
    ff          6/subop/push        1/mod/*+disp8   5/rm32/ebp    .           .             .           .           0xc/disp8       .                 # push *(ebp+12)
    ff          6/subop/push        1/mod/*+disp8   5/rm32/ebp    .           .             .           .           8/disp8         .                 # push *(ebp+8)
    # . . call
    e8/call  check-trace-scans-to/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               8/imm32           # add to esp
$check-trace-contains:end:
    # . epilogue
    89/copy                         3/mod/direct    4/rm32/esp    .           .             .           5/r32/ebp   .               .                 # copy ebp to esp
    5d/pop-to-ebp
    c3/return

check-trace-scans-to:  # line : (address string), msg : (address string)
    # . prologue
    55/push-ebp
    89/copy                         3/mod/direct    5/rm32/ebp    .           .             .           4/r32/esp   .               .                 # copy esp to ebp
    # . save registers
    50/push-eax
    # eax = trace-scan(line)
    # . . push args
    ff          6/subop/push        1/mod/*+disp8   5/rm32/ebp    .           .             .           .           8/disp8         .                 # push *(ebp+8)
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # check-ints-equal(eax, 1, msg)
    # . . push args
    ff          6/subop/push        1/mod/*+disp8   5/rm32/ebp    .           .             .           .           0xc/disp8       .                 # push *(ebp+12)
    68/push  1/imm32
    50/push-eax
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
$check-trace-scans-to:end:
    # . restore registers
    58/pop-to-eax
    # . epilogue
    89/copy                         3/mod/direct    4/rm32/esp    .           .             .           5/r32/ebp   .               .                 # copy ebp to esp
    5d/pop-to-ebp
    c3/return

# Start scanning from Trace-stream->read for 'line'. If found, update Trace-stream->read and return true.
trace-scan:  # line : (address string) -> result/eax : boolean
    # pseudocode:
    #   push Trace-stream->read
    #   while true:
    #     if Trace-stream->read >= Trace-stream->write
    #       break
    #     if next-line-matches?(Trace-stream, line)
    #       skip-next-line(Trace-stream)
    #       dump saved copy of Trace-stream->read
    #       return true
    #     skip-next-line(Trace-stream)
    #   pop saved copy of Trace-stream->read
    #   return false
    #
    # . prologue
    55/push-ebp
    89/copy                         3/mod/direct    5/rm32/ebp    .           .             .           4/r32/esp   .               .                 # copy esp to ebp
    # . save registers
    51/push-ecx
    56/push-esi
    # esi = *Trace-stream
    8b/copy                         0/mod/indirect  5/rm32/.disp32            .             .           6/r32/esi   Trace-stream/disp32               # copy *Trace-stream to esi
    # ecx = Trace-stream->write
    8b/copy                         0/mod/indirect  6/rm32/esi    .           .             .           1/r32/ecx                   .                 # copy *esi to ecx
    # push Trace-stream->read
    ff          6/subop/push        1/mod/*+disp8   6/rm32/esi    .           .             .           .           4/disp8         .                 # push *(esi+4)
$trace-scan:loop:
    # if (Trace-stream->read >= Trace-stream->write) return false
    39/compare                      1/mod/*+disp8   6/rm32/esi    .           .             .           1/r32/ecx   4/disp8         .                 # compare ecx with *(esi+4)
    7d/jump-if-greater-or-equal  $trace-scan:false/disp8
    # eax = next-line-matches?(Trace-stream, line)
    # . . push args
    ff          6/subop/push        1/mod/*+disp8   5/rm32/ebp    .           .             .           .           8/disp8         .                 # push *(ebp+8)
    56/push-esi
    # . . call
    e8/call  next-line-matches?/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               8/imm32           # add to esp
    # if (eax == 0) continue
    3d/compare-eax-and  0/imm32
    74/jump-if-equal  $trace-scan:continue/disp8
$trace-scan:true:
    # skip-next-line(Trace-stream)
    # . . push args
    56/push-esi
    # . . call
    e8/call  skip-next-line/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # dump saved copy of Trace-stream->read
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # return true
    b8/copy-to-eax  1/imm32/true
    eb/jump  $trace-scan:end/disp8
$trace-scan:continue:
    # skip-next-line(Trace-stream)
    # . . push args
    56/push-esi
    # . . call
    e8/call  skip-next-line/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    eb/jump  $trace-scan:loop/disp8
$trace-scan:false:
    # restore saved copy of Trace-stream->read
    8f          0/subop/pop         1/mod/*+disp8   6/rm32/esi    .           .             .           .           4/disp8         .                 # pop to *(esi+4)
    # return false
    b8/copy-to-eax  0/imm32/false
$trace-scan:end:
    # . restore registers
    59/pop-to-ecx
    # . epilogue
    89/copy                         3/mod/direct    4/rm32/esp    .           .             .           5/r32/ebp   .               .                 # copy ebp to esp
    5d/pop-to-ebp
    c3/return

test-trace-scan-first:
    # push *Trace-stream
    ff          6/subop/push        0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # push *Trace-stream
    # setup
    # . *Trace-stream = _test-trace-stream
    b8/copy-to-eax  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/eax   Trace-stream/disp32               # copy eax to *Trace-stream
    # . clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # . trace("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # eax = trace-scan("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # check-ints-equal(eax, 1, msg)
    # . . push args
    68/push  "F - test-trace-scan-first"/imm32
    68/push  1/imm32
    50/push-eax
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    # pop into *Trace-stream
    8f          0/subop/pop         0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # pop into *Trace-stream
    # . end
    c3/return

test-trace-scan-skips-lines-until-found:
    # push *Trace-stream
    ff          6/subop/push        0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # push *Trace-stream
    # setup
    # . *Trace-stream = _test-trace-stream
    b8/copy-to-eax  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/eax   Trace-stream/disp32               # copy eax to *Trace-stream
    # . clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # . trace("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # . trace("cd")
    # . . push args
    68/push  "cd"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # eax = trace-scan("cd")
    # . . push args
    68/push  "cd"/imm32
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # check-ints-equal(eax, 1, msg)
    # . . push args
    68/push  "F - test-trace-scan-skips-lines-until-found"/imm32
    68/push  1/imm32
    50/push-eax
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    # pop into *Trace-stream
    8f          0/subop/pop         0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # pop into *Trace-stream
    # . end
    c3/return

test-trace-second-scan-starts-where-first-left-off:
    # push *Trace-stream
    ff          6/subop/push        0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # push *Trace-stream
    # setup
    # . *Trace-stream = _test-trace-stream
    b8/copy-to-eax  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/eax   Trace-stream/disp32               # copy eax to *Trace-stream
    # . clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # . trace("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # . eax = trace-scan("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # second scan fails
    # . eax = trace-scan("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # check-ints-equal(eax, 0, msg)
    # . . push args
    68/push  "F - test-trace-second-scan-starts-where-first-left-off"/imm32
    68/push  0/imm32
    50/push-eax
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    # pop into *Trace-stream
    8f          0/subop/pop         0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # pop into *Trace-stream
    # . end
    c3/return

test-trace-scan-failure-leaves-read-index-untouched:
    # push *Trace-stream
    ff          6/subop/push        0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # push *Trace-stream
    # setup
    # . *Trace-stream = _test-trace-stream
    b8/copy-to-eax  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/eax   Trace-stream/disp32               # copy eax to *Trace-stream
    # . clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # . trace("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # . check-ints-equal(_test-trace-stream->read, 0, msg)
    # . . push args
    68/push  "F - test-trace-second-scan-starts-where-first-left-off/precondition-failure"/imm32
    68/push  0/imm32
    b8/copy-to-eax  _test-trace-stream/imm32
    ff          6/subop/push        1/mod/*+disp8   0/rm32/eax    .           .             .           .           4/disp8         .                 # push *(eax+4)
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    # perform a failing scan
    # . eax = trace-scan("Ax")
    # . . push args
    68/push  "Ax"/imm32
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # no change in read index
    # . check-ints-equal(_test-trace-stream->read, 0, msg)
    # . . push args
    68/push  "F - test-trace-second-scan-starts-where-first-left-off"/imm32
    68/push  0/imm32
    b8/copy-to-eax  _test-trace-stream/imm32
    ff          6/subop/push        1/mod/*+disp8   0/rm32/eax    .           .             .           .           4/disp8         .                 # push *(eax+4)
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    # pop into *Trace-stream
    8f          0/subop/pop         0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # pop into *Trace-stream
    # . end
    c3/return

next-line-matches?:  # t : (address stream), line : (address string) -> result/eax : boolean
    # pseudocode:
    #   while true:
    #     if (currl >= maxl) break
    #     if (currt >= maxt) return false
    #     if (*currt != *currl) return false
    #     ++currt
    #     ++currl
    #   return *currt == '\n'
    #
    # . prologue
    55/push-ebp
    89/copy                         3/mod/direct    5/rm32/ebp    .           .             .           4/r32/esp   .               .                 # copy esp to ebp
    # . save registers
    51/push-ecx
    52/push-edx
    53/push-ebx
    56/push-esi
    57/push-edi
    # edx = line
    8b/copy                         1/mod/*+disp8   5/rm32/ebp    .           .                         2/r32/edx   0xc/disp8       .                 # copy *(ebp+12) to edx
    # currl/esi = line->data
    # . esi = line/edx->data
    8d/copy-address                 1/mod/*+disp8   2/rm32/edx    .           .             .           6/r32/esi   4/disp8         .                 # copy edx+4 to esi
    # maxl/ecx = line->data + line->size
    # . eax = line/edx->size
    8b/copy                         0/mod/indirect  2/rm32/edx    .           .                         0/r32/eax   .               .                 # copy *edx to eax
    # . maxl/ecx = line->data/esi + line->size/eax
    8d/copy-address                 0/mod/indirect  4/rm32/sib    6/base/esi  0/index/eax   .           1/r32/ecx   .               .                 # copy edx+eax to ecx
    # edi = t
    8b/copy                         1/mod/*+disp8   5/rm32/ebp    .           .                         7/r32/edi   8/disp8         .                 # copy *(ebp+8) to edi
    # ebx = t->data
    8d/copy-address                 1/mod/*+disp8   7/rm32/edi    .           .             .           3/r32/ebx   0xc/disp8       .                 # copy edi+12 to ebx
    # maxt/edx = t->data + t->write
    # . eax = t->write
    8b/copy                         0/mod/indirect  7/rm32/edi    .           .                         0/r32/eax   .               .                 # copy *edi to eax
    # . maxt/edx = t->data/ebx + t->write/eax
    8d/copy-address                 0/mod/indirect  4/rm32/sib    3/base/ebx  0/index/eax   .           2/r32/edx   .               .                 # copy ebx+eax to edx
    # currt/edi = t->data + t->read
    # . eax = t/edi->read
    8b/copy                         1/mod/*+disp8   7/rm32/edi    .           .                         0/r32/eax   4/disp8         .                 # copy *(edi+4) to eax
    # . currt/edi = t->data/ebx + t->read/eax
    8d/copy-address                 0/mod/indirect  4/rm32/sib    3/base/ebx  0/index/eax   .           7/r32/edi   .               .                 # copy ebx+eax to edi
$next-line-matches?:loop:
    # if (currl/esi >= maxl/ecx) break
    39/compare                      3/mod/direct    6/rm32/esi    .           .             .           1/r32/ecx   .               .                 # compare esi and ecx
    73/jump-if-greater-or-equal-unsigned  $next-line-matches?:break/disp8
    # if (currt/edi >= maxt/edx) return false
    # . eax = false
    b8/copy-to-eax  0/imm32/false
    39/compare                      3/mod/direct    7/rm32/edi    .           .             .           2/r32/edx   .               .                 # compare edi and edx
    73/jump-if-greater-or-equal-unsigned  $next-line-matches?:end/disp8
    # if (*currt/edi != *currl/esi) return false
    31/xor                          3/mod/direct    0/rm32/eax    .           .             .           0/r32/eax   .               .                 # clear eax
    31/xor                          3/mod/direct    3/rm32/eax    .           .             .           3/r32/eax   .               .                 # clear ebx
    # . eax = (char) *currt/edi
    8a/copy-byte                    0/mod/indirect  7/rm32/edi    .           .                         0/r32/eax   .               .                 # copy *edi to eax
    # . ebx = (char) *currl/esi
    8a/copy-byte                    0/mod/indirect  6/rm32/esi    .           .                         3/r32/ebx   .               .                 # copy *esi to ebx
    # . eax >= ebx
    39/compare                      3/mod/direct    0/rm32/eax    .           .             .           3/r32/ebx   .               .                 # compare eax and ebx
    # . eax = false
    b8/copy-to-eax  0/imm32/false
    75/jump-if-not-equal  $next-line-matches?:end/disp8
    # ++currt/edi
    47/increment-edi
    # ++currl/esi
    46/increment-esi
    eb/jump  $next-line-matches?:loop/disp8
$next-line-matches?:break:
    # return *currt == '\n'
    31/xor                          3/mod/direct    0/rm32/eax    .           .             .           0/r32/eax   .               .                 # clear eax
    # . eax = (char) *currt
    8a/copy-byte                    0/mod/indirect  7/rm32/edi    .           .                         0/r32/eax   .               .                 # copy *edi to eax
    3d/compare-eax-and  0xa/imm32/newline
    # . eax = false
    b8/copy-to-eax  1/imm32/true
    74/jump-if-equal  $next-line-matches?:end/disp8
    b8/copy-to-eax  0/imm32/true
$next-line-matches?:end:
    # . restore registers
    5f/pop-to-edi
    5e/pop-to-esi
    5b/pop-to-ebx
    5a/pop-to-edx
    59/pop-to-ecx
    # . epilogue
    89/copy                         3/mod/direct    4/rm32/esp    .           .             .           5/r32/ebp   .               .                 # copy ebp to esp
    5d/pop-to-ebp
    c3/return

test-next-line-matches?-no-match-1:
    # next line of "ABABA" does not match "blah blah"
    # . eax = next-line-matches?(_test-stream-line-ABABA, "blah blah")
    # . . push args
    68/push  "blah blah"/imm32
    68/push  _test-stream-line-ABABA/imm32
    # . . call
    e8/call  next-line-matches?/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               8/imm32           # add to esp
    # . check-ints-equal(eax, 0, msg)
    # . . push args
    68/push  "F - test-next-line-matches?-no-match-1"/imm32
    68/push  0/imm32
    50/push-eax
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    c3/return

test-next-line-matches?-no-match-2:
    # next line of "ABABA" does not match ""
    # . eax = next-line-matches?(_test-stream-line-ABABA, "")
    # . . push args
    68/push  ""/imm32
    68/push  _test-stream-line-ABABA/imm32
    # . . call
    e8/call  next-line-matches?/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               8/imm32           # add to esp
    # . check-ints-equal(eax, 0, msg)
    # . . push args
    68/push  "F - test-next-line-matches?-no-match-2"/imm32
    68/push  0/imm32
    50/push-eax
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    c3/return

test-next-line-matches?-no-match-3:
    # next line of "ABABA" does not match  "AA"
    # . eax = next-line-matches?(_test-stream-line-ABABA, "AA")
    # . . push args
    68/push  "AA"/imm32
    68/push  _test-stream-line-ABABA/imm32
    # . . call
    e8/call  next-line-matches?/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               8/imm32           # add to esp
    # . check-ints-equal(eax, 0, msg)
    # . . push args
    68/push  "F - test-next-line-matches?-no-match-3"/imm32
    68/push  0/imm32
    50/push-eax
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    c3/return

test-next-line-matches?-match:
    # next line of "ABABA" matches "ABABA"
    # . eax = next-line-matches?(_test-stream-line-ABABA, "ABABA")
    # . . push args
    68/push  "ABABA"/imm32
    68/push  _test-stream-line-ABABA/imm32
    # . . call
    e8/call  next-line-matches?/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               8/imm32           # add to esp
    # . check-ints-equal(eax, 1, msg)
    # . . push args
    68/push  "F - test-next-line-matches?-match"/imm32
    68/push  1/imm32
    50/push-eax
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    c3/return

# move t->read to _after_ next newline
skip-next-line:  # t : (address stream)
    # pseudocode:
    #   max = t->data + t->write
    #   i = t->read
    #   curr = t->data + t->read
    #   while true
    #     if (curr >= max) break
    #     ++i
    #     if (*curr == '\n') break
    #     ++curr
    #   t->read = i
    #
    # . prologue
    55/push-ebp
    89/copy                         3/mod/direct    5/rm32/ebp    .           .             .           4/r32/esp   .               .                 # copy esp to ebp
    # . save registers
    50/push-eax
    51/push-ecx
    52/push-edx
    53/push-ebx
    # ecx = t
    8b/copy                         1/mod/*+disp8   5/rm32/ebp    .           .                         1/r32/ecx   8/disp8         .                 # copy *(ebp+8) to ecx
    # edx = t/ecx->data
    8d/copy-address                 1/mod/*+disp8   1/rm32/ecx    .           .             .           2/r32/edx   0xc/disp8       .                 # copy ecx+12 to edx
    # eax = t/ecx->write
    8b/copy                         0/mod/indirect  1/rm32/ecx    .           .             .           0/r32/eax   .               .                 # copy *ecx to eax
    # max/ebx = t->data/edx + t->write/eax
    8d/copy-address                 0/mod/indirect  4/rm32/sib    2/base/edx  0/index/eax   .           3/r32/ebx   .               .                 # copy edx+eax to ebx
    # eax = t/ecx->read
    8b/copy                         1/mod/*+disp8   1/rm32/ecx    .           .             .           0/r32/eax   4/disp8         .                 # copy *(ecx+4) to edx
    # curr/ecx = t->data/edx + t->read/eax
    8d/copy-address                 0/mod/indirect  4/rm32/sib    2/base/edx  0/index/eax   .           1/r32/ecx   .               .                 # copy edx+eax to ecx
    # i/edx = eax
    89/copy                         3/mod/direct    2/rm32/edx    .           .             .           0/r32/eax   .               .                 # copy eax to edx
$skip-next-line:loop:
    # if (curr/ecx >= max/ebx) break
    39/compare                      3/mod/direct    1/rm32/ecx    .           .             .           3/r32/ebx   .               .                 # compare ecx and ebx
    73/jump-if-greater-or-equal-unsigned  $skip-next-line:end/disp8
    # ++i/edx
    42/increment-edx
    # if (*curr/ecx == '\n') break
    31/xor                          3/mod/direct    0/rm32/eax    .           .             .           0/r32/eax   .               .                 # clear eax
    8a/copy-byte                    0/mod/indirect  1/rm32/ecx    .           .             .           0/r32/eax   .               .                 # copy *ecx to eax
    3d/compare-eax-and  0a/imm32/newline
    74/jump-if-equal  $skip-next-line:end/disp8
    # ++curr/ecx
    41/increment-ecx
    # loop
    eb/jump  $skip-next-line:loop/disp8
$skip-next-line:end:
    # ecx = t
    8b/copy                         1/mod/*+disp8   5/rm32/ebp    .           .                         1/r32/ecx   8/disp8         .                 # copy *(ebp+8) to ecx
    # t/ecx->read = i/edx
    89/copy                         1/mod/*+disp8   1/rm32/ecx    .           .             .           2/r32/edx   4/disp8         .                 # copy edx to *(ecx+4)
    # . restore registers
    5b/pop-to-ebx
    5a/pop-to-edx
    59/pop-to-ecx
    58/pop-to-eax
    # . epilogue
    89/copy                         3/mod/direct    4/rm32/esp    .           .             .           5/r32/ebp   .               .                 # copy ebp to esp
    5d/pop-to-ebp
    c3/return

test-skip-next-line-empty:
    # skipping next line in empty stream leaves read pointer at 0
    # . skip-next-line(_test-stream-empty)
    # . . push args
    68/push  _test-stream-empty/imm32
    # . . call
    e8/call  skip-next-line/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # . check-ints-equal(_test-stream-empty->read, 0, msg)
    # . . push args
    68/push  "F - test-skip-next-line-empty"/imm32
    68/push  0/imm32
    b8/copy-to-eax  _test-stream-empty/imm32
    8b/copy                         1/mod/*+disp8   0/rm32/eax    .           .             .           0/r32/eax   4/disp8         .                 # copy *(eax+4) to eax
    50/push-eax
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    c3/return

test-skip-next-line-filled:
    # skipping next line increments read pointer by length of line + 1 (for newline)
    # . skip-next-line(_test-stream-filled)
    # . . push args
    68/push  _test-stream-filled/imm32
    # . . call
    e8/call  skip-next-line/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               4/imm32           # add to esp
    # . check-ints-equal(_test-stream-filled->read, 5, msg)
    # . . push args
    68/push  "F - test-skip-next-line-filled"/imm32
    68/push  5/imm32
    b8/copy-to-eax  _test-stream-filled/imm32
    8b/copy                         1/mod/*+disp8   0/rm32/eax    .           .             .           0/r32/eax   4/disp8         .                 # copy *(eax+4) to eax
    50/push-eax
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0xc/imm32         # add to esp
    c3/return

clear-trace-stream:
    # . prologue
    55/push-ebp
    89/copy                         3/mod/direct    5/rm32/ebp    .           .             .           4/r32/esp   .               .                 # copy esp to ebp
    # . save registers
    50/push-eax
    51/push-ecx
    # eax = *Trace-stream
    8b/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/eax   Trace-stream/disp32               # copy *Trace-stream to eax
    # ecx = t->length
    8b/copy                         1/mod/*+disp8   0/rm32/eax    .           .             .           1/r32/ecx   8/disp8         .                 # copy *(eax+8) to ecx
    # ecx = &t->data[t->length]
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    0/base/eax  1/index/ecx   .           1/r32/ecx   0xc/disp8       .                 # copy eax+ecx+12 to ecx
    # t->write = 0
    c7          0/subop/copy        0/mod/direct    0/rm32/eax    .           .             .           .           .               0/imm32           # copy to *eax
    # t->read = 0
    c7          0/subop/copy        1/mod/*+disp8   0/rm32/eax    .           .             .           .           4/disp8         0/imm32           # copy to *(eax+4)
    # eax = t->data
    81          0/subop/add         3/mod/direct    0/rm32/eax    .           .             .           .           .               0xc/imm32         # add to eax
$clear-trace-stream:loop:
    # if (eax >= ecx) break
    39/compare                      3/mod/direct    0/rm32/eax    .           .             .           1/r32/ecx   .               .                 # compare eax with ecx
    73/jump-if-greater-or-equal-unsigned  $clear-trace-stream:end/disp8
    # *eax = 0
    c7          0/subop/copy        0/mod/direct    0/rm32/eax    .           .             .           .           .               0/imm32           # copy to *eax
    # eax += 4
    81          0/subop/add         3/mod/direct    0/rm32/eax    .           .             .           .           .               4/imm32           # add to eax
    eb/jump  $clear-trace-stream:loop/disp8
$clear-trace-stream:end:
    # . restore registers
    59/pop-to-ecx
    58/pop-to-eax
    # . epilogue
    89/copy                         3/mod/direct    4/rm32/esp    .           .             .           5/r32/ebp   .               .                 # copy ebp to esp
    5d/pop-to-ebp
    c3/return

# - helpers

# 3-argument variant of _append
_append-3:  # out : address, outend : address, s : (array byte) -> num_bytes_appended/eax
    # . prologue
    55/push-ebp
    89/copy                         3/mod/direct    5/rm32/ebp    .           .             .           4/r32/esp   .               .                 # copy esp to ebp
    # . save registers
    51/push-ecx
    # eax = _append-4(out, outend, &s->data[0], &s->data[s->length])
    # . . push &s->data[s->length]
    8b/copy                         1/mod/*+disp8   5/rm32/ebp    .           .                         0/r32/eax   0x10/disp8      .                 # copy *(ebp+16) to eax
    8b/copy                         0/mod/indirect  0/rm32/eax    .           .             .           1/r32/ecx   .               .                 # copy *eax to ecx
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    0/base/eax  1/index/ecx   .           1/r32/ecx   4/disp8         .                 # copy eax+ecx+4 to ecx
    51/push-ecx
    # . . push &s->data[0]
    8d/copy-address                 1/mod/*+disp8   0/rm32/eax    .           .             .           1/r32/ecx   4/disp8         .                 # copy eax+4 to ecx
    51/push-ecx
    # . . push outend
    ff          6/subop/push        1/mod/*+disp8   5/rm32/ebp    .           .             .           .           0xc/disp8       .                 # push *(ebp+12)
    # . . push out
    ff          6/subop/push        1/mod/*+disp8   5/rm32/ebp    .           .             .           .           8/disp8         .                 # push *(ebp+8)
    # . . call
    e8/call  _append-4/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               0x10/imm32        # add to esp
$_append-3:end:
    # . restore registers
    59/pop-to-ecx
    # . epilogue
    89/copy                         3/mod/direct    4/rm32/esp    .           .             .           5/r32/ebp   .               .                 # copy ebp to esp
    5d/pop-to-ebp
    c3/return

# 4-argument variant of _append
_append-4:  # out : address, outend : address, in : address, inend : address -> num_bytes_appended/eax
    # . prologue
    55/push-ebp
    89/copy                         3/mod/direct    5/rm32/ebp    .           .             .           4/r32/esp   .               .                 # copy esp to ebp
    # . save registers
    51/push-ecx
    52/push-edx
    53/push-ebx
    56/push-esi
    57/push-edi
    # eax/num_bytes_appended = 0
    b8/copy-to-eax  0/imm32
    # edi = out
    8b/copy                         1/mod/*+disp8   5/rm32/ebp    .           .             .           7/r32/edi   8/disp8         .                 # copy *(ebp+8) to edi
    # edx = outend
    8b/copy                         1/mod/*+disp8   5/rm32/ebp    .           .             .           2/r32/edx   0xc/disp8       .                 # copy *(ebp+12) to edx
    # esi = in
    8b/copy                         1/mod/*+disp8   5/rm32/ebp    .           .             .           6/r32/esi   0x10/disp8      .                 # copy *(ebp+16) to esi
    # ecx = inend
    8b/copy                         1/mod/*+disp8   5/rm32/ebp    .           .             .           1/r32/ecx   0x14/disp8      .                 # copy *(ebp+20) to ecx
$_append-4:loop:
    # if (in >= inend) break
    39/compare                      3/mod/direct    6/rm32/esi    .           .             .           1/r32/ecx   .               .                 # compare esi with ecx
    73/jump-if-greater-or-equal-unsigned  $_append-4:end/disp8
    # if (out >= outend) abort  # just to catch test failures fast
    39/compare                      3/mod/direct    7/rm32/edi    .           .             .           2/r32/edx   .               .                 # compare edi with edx
    73/jump-if-greater-or-equal-unsigned  $_append-4:abort/disp8
    # *out = *in
    8a/copy-byte                    0/mod/indirect  6/rm32/esi    .           .             .           3/r32/BL    .               .                 # copy byte at *esi to BL
    88/copy-byte                    0/mod/indirect  7/rm32/edi    .           .             .           3/r32/BL    .               .                 # copy byte at BL to *edi
    # ++num_bytes_appended
    40/increment-eax
    # ++in
    46/increment-esi
    # ++out
    47/increment-edi
    eb/jump  $_append-4:loop/disp8
$_append-4:end:
    # . restore registers
    5f/pop-to-edi
    5e/pop-to-esi
    5b/pop-to-ebx
    5a/pop-to-edx
    59/pop-to-ecx
    # . epilogue
    89/copy                         3/mod/direct    4/rm32/esp    .           .             .           5/r32/ebp   .               .                 # copy ebp to esp
    5d/pop-to-ebp
    c3/return

$_append-4:abort:
    # . _write(2/stderr, error)
    # . . push args
    68/push  "stream overflow\n"/imm32
    68/push  2/imm32/stderr
    # . . call
    e8/call  _write/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/esp    .           .             .           .           .               8/imm32           # add to esp
    # . syscall(exit, 1)
    bb/copy-to-ebx  1/imm32
    b8/copy-to-eax  1/imm32/exit
    cd/syscall  0x80/imm8
    # never gets here

== data

_test-stream-line-ABABA:
    # write
    8/imm32
    # read
    0/imm32
    # length
    8/imm32
    # data
    41 42 41 42 41 0a 00 00  # 8 bytes

_test-stream-empty:
    # write
    0/imm32
    # read
    0/imm32
    # length
    8/imm32
    # data
    00 00 00 00 00 00 00 00  # 8 bytes

_test-stream-filled:
    # write
    8/imm32
    # read
    0/imm32
    # length
    8/imm32
    # data
    41 41 41 41 0a 41 41 41  # 8 bytes

# . . vim:nowrap:textwidth=0
